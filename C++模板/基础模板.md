> ## [返回索引](./index.md)

模板以template关键字定义，语法是template <模板参数>

模板参数分为类型参数和值参数，类型参数以typename或class关键字进行定义，参数可以没有名字而是一个占位参数，例如:
```template <typename T>```
如果是值参数的话就是例如`template <int T>`这个T可以改为别的名字，**需要注意的是值参数的模板的值参数类型必须为标量类型(即基本数据类型)或枚举类型**，错误示范:
```template <std::string T>```
在使用template关键字定义后此关键字下方定义的东西会被视为模板例如:
```
template <typename T>
T a = 123;
```
使用时必须加上\<\>给模板传参: ```a<int>```(也就是说传参的<>是在标识符后面的，如果是个函数那么调用的()就在<>后面)

- 模板只能作用于:
	1. 函数(非main)/类(包括结构体与联合体但不包含枚举)\[/对象(包含自定义类型与基本数据类型) (Since: C++14)\]
	2. using定义的类型别名
	3. 模板(template嵌套)
- 补充:
    1. 模板可以有默认实参例如`template <typename T = int>`，占位的参数及值参数也可以拥有:
	```
	template <typename = int>
	template <int = 123>
	```
    2. 在使用模板时是直接进行替换的(但对于类型参数的并不是完全简简单单的直接替换)，例如参数是int值为123那么使用它就会被替换为123，如果参数是long值为123那么使用它就会替换为123L，这也就是为什么自定义类型不可成为模板参数类型的原因，因为自定义类型没有固定的字面量

	需要注意的是模板形参可以是指针，虽然指针没有什么字面量但这仍然是可以的，例如:
	```
	template <int* p>
	void fn() {}
	```
	那么如果传入一个&a那么函数fn的所有使用p的地方都会替换为指向a的指针，需要注意的是这个a必须有静态存储期
    3. 模板只有在使用时才会进行编译，这个过程叫做“实例化”tip: 多次使用且模板参数一样不会实例化多次
    4. 若类型模板形参出现在函数形参上那么它可以进行类型推导例如:  
        ```
        template <typename T>
        void FN(T) {}
        ```  
        不是类型的也可以例如:  
        ```
        template <typename T, size_t S>
        void FN(T(&)[S]) {}
        ```  
        此时就算不给传入模板类型例如直接FN(1)或FN\<\>(1)，T都能被推导为int，但是需要注意的是模板上的默认实参不能不写\<\>，它可以为空但是必须写出  
	但是仅限直接的，如果是间接的即被加工后的模板形参那么它不能被推导，例如:
	```
	template <typename T>
	void fn(std::add_const_t<T>& v) {
	}
	```
    5. 在函数模板与普通函数重载时若2者都能调用会优先使用普通函数
    6. 在C++14前单独的对象不能作为模板例如
        ```
        template <typename T>
        T a = 123;
        ```
    7. 在编译器实例化模板时如果遇到问题导致无法继续实例化应该再找找有没有其它可用的模板，如果未找到再报错，这个叫SFINAE("替换失败不是错误")
    8. XX模板和模板XX是2个概念，例如类模板和模板类分别是`template <typename T> class A`和`A<int>`

	需要注意的是模板函数可以被视为普通的函数(若所有模板参数都显式提供，类同理)
    9. 在使用类模板时如果使用它创建右值对象(即匿名对象)或作为函数形参或单独作为类型使用则它必须加上\<\>即使它有默认实参或可以自动推导
    10. C++17起当类模板的模板类型参数写成在了构造上，那么此类型参数可以推导类型就像推导指引(推导指引在后面)一样，这个叫CTAD，在CTAD发生时模板实参必须为空(并且尖括号也不能写)，例如:
	```
	template <typename T>
	struct A {
		A(T) {}
	};
	```
	此时若 `A a(123)`这样定义是合法的但是`A<> a(123)`不合法(你要问`A<int> a(123)`合不合法答案是合法因为根本没发生CTAD)
11. 类模板无法在定义类的同时声明对象例如:
    ```
	template <typename T>
    class A {
    } obj;
    ```
12. 类模板使用本类类型时可以不填模板类型，类型为当前模板类的类型例如`template <typename T> class A`在使用A这个类模板类型时默认使用当前模板类类型，例如`A<int>`在这个模板类里面如果直接使用A这个类型就是使用`A<int>`类型
13. 类模板里面成员不是模板
14. 对于类模板的类内声明类外实现的类外实现的定义需要加上template关键字且与类模板的声明一样例如:
        ```
        template <typename T>
        struct A {
        void FN();
        };
        template <typename T>
        void A<T>::FN() {
        }
        ```
        注: 这种类外实现的定义的模板参数个数不得多于类模板的个数，类外定义的模板参数标识符可以与原本的不一样，如果函数声明不一样那么是UB例如:
        ```
        template <typename> class T {};
        template <typename U>
        struct A {
            void FN(T<U>) {}
        };
        template <typename U>
        void A<U>::FN(T<int>) {/* 不建议这样写，即使使用模板类时U确实是int */
        }
        ```
15. (对14的补充)，若类内的声明也是模板那么类外实现要写2个template:
        ```
        template <typename T>
        struct A {
        template <typename U>
            void FN();
        };
        template <typename T>
        template <typename U>
        void A<T>::FN() {
        }
        ```
16. 模板不能夸文件使用(模板类的对象可以)，除非以include的方式使用
17. typename关键字还可以限定一个东西必须为类型，不过必须使用::访问此类型例如`typename ::size_t a`
18. 如果类模板里面使用了一个模板且这个模板有一个实参依赖于此类模板的实参那么这个模板的实例化就会被推迟到此类模板实例化后，例如类模板A使用类模板B的type类型别名，而类模板B的模板实参依赖于A的模板实参那么B的实例化会被推迟到类模板A实例化后，那么如果直接使用B的type类型别名编译器会认为这是静态数据成员，这个时候访问B的type类型别名就必须加上typename关键字(用来告诉编译器这是类型而不是数据成员)，注: 如果一个模板没有实例化任何一个版本那么编译器也会对它的内容进行语法检查
19. 值参数的模板不能为数组与指针和引用类型，即使你编译对了也没法传入参数
20. 类似于18，只不过不是类型别名而是模板函数，假设访问B的模板函数FN(假设已经有了一个B对象t)那么需要`t.template FN</* 一些模板参数 */>()`来使用，全局(或者是静态的成员函数)的也可以这样加上template关键字进行调用(对于全局等其它地方的必须使用::来访问此函数)，除了.之外->也可以这样就像是`t->template FN</* ... */>()`这样(这里如果不加编译器会认为它是普通的函数，即非模板的)
 21. 函数里不能出现template关键字，不管发生什么
 22. 模板的参数名字不能与模板重名，错误示范:
        ```
        template <typename T>
        class T {
            
        };
        ```
23. 一个模板的实例化个数是有限制的，各家编译器的数量限制都不一样(隐约记得clang是1024)
24. 值参数的模板的类型可以为模板类型
25. 因为模板是编译时进行特化的所以你给模板的实参也必须是编译时可确定的，例如你没法给模板传入time(0)因为时间戳编译时无法确定
26. 只有以下东西可以成为模板:
	- 类、结构体及联合体
	- 函数
	- using别名(C++11起)
	- 对象(C++14起)
27. 一个模板它的不同实例化是2个东西而不是一个东西，例如`A<int>`与`A<long>`是两个模板类，这两个模板类的数据成员都是占不同地址的
28. 模板的自动推导不能发生冲突，例如:
	```
	template <typename T>
	void FN(T,T) {}
	```
	如果`FN(1,1L)`这样就会因为一个推导类型int一个推导long而起冲突
29. 不同模板类是不能直接访问的，例如`a<int>`类里面不能访问`a<long>`的成员，因为这是2个类
30. 以下这种情况:
	```
	template <long T>
	void FN(A<T>) {}
	```
	若这种推导的话传入A<1>类型那么这个函数会因类型不匹配而报错(假设A类的值模板参数类型是int)，因为编译器认为FN函数的A类模板的值模板参数是long类型而你给的是int类型(即`template <int> class A;`与`template <long> class A`之间不能转换)
31. 对于模板函数与模板函数的重载时这种情况:
	```
	template <typename T>
	void FN(T a) {}
	template <typename>
	void FN(int) {}
	```
	这时以`FN<int>(1)`进行使用会优先使用参数是写死类型的版本，也就是说参数是模板类型的模板函数进行重载会优先使用参数描述更详细的版本
32. 发生自动推导时不会隐式转换，例如函数:
	```
	template <typename T, size_t S>
	void demo(T(&)[S]) {}
	```
	这个函数的传参是任意左值表达式的数组，但是如果传入一个自定义类型的对象那么它永远会报错，即使这个对象可以隐式转换为数组类型(如果是强转那么可以)，且即使显式提供了T的类型也会报错(因为只要发生了自动推导那么就不会隐式转换，如果同时显式提供T和S那么是可以的)
33. 当函数参数为模板或是CTAD时，模板的自动推导类型必须依靠实参，而不能依靠默认实参，例如:
	```
	template <typename T>
		void FN(T = 0) {}//无法推导int，毕竟函数板的实例化只有在使用时嘛:D
	```
	这种情况下`FN()`调用不会通过编译，因为T需要依靠实参进行自动推导类型如果这样的话就无法推导出类型，除非`FN<int>()`这样调用
34. 虚函数不能作为函数模板
35. 以下这种情况:
	```
	struct B {
		int value = 123;
	};
	template <class T>
	struct A : public T {
	};
	```
	那么模板类A的模板实参就必须是一个不为联合体自定义类型(换句话说就是必须是struct或class)，并且`A<const B>`与`A<B>`是相同的
36. 若构造为函数模板，那么在使用时无法显式给此模板传入实参