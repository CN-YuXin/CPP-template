> ## [返回索引](./index.md)

模板的特化就是特化一个模板在某种情况下时使用特化的版本而不是主版本，特化的声明需要与主模板的声明一致(虽然你主模板class特化struct也是可以的不过不建议)，示例:
```
template <typename T>
class L {
};
template <typename T>
class L<const T> {/* 特化版本 */
};
```
这个特化会在L类的T类型为带const的任意类型时被使用(特化的template必须写)，所以特化的语法就是:
```
template <模板参数>
主模板定义 主模板名<特化的情况> 特化的定义
```

- 补充:
    1. 特化的每个模板参数都要用于特化，错误示范:
        ```
        template <typename T>
        class L {
            
        };
        template <typename T, typename U>
        class L<const T> {
            
        };
        ```
    2. 特化的模板参数不能有默认实参
    3. 如果主模板使用特化的模板是不用声明的，因为这是同一个东西
    4. 如果特化的是函数那么特化版本不能有默认实参
    5. 如果特化时使用了模板参数那么这种特化叫做偏特化，如果没有那么就是全特化
    6. 函数无法偏特化，因为这样编译器无法进行区分函数重载和函数偏特化(不过template还是要写的)
    7. 类型别名无法特化
    8. 函数特化不能改变返回值、参数个数、参数类型、修饰及限定，换句话说就是主函数模板与特化版本的声明必须完全相同
    9. C++14起模板对象可以被特化
    10. 特化时也可以进行推导:
        ```
        template <typename T>
        void FN(T) {
            
        }
        template <>
        void FN(int) {/* 相当于void FN<int>(int) */
            
        }
        ```
    11. 特化的模板里不可使用decltype
    12. 不可重复定义一个特化或者说是特化内容一样的特化
    13. 如果一个特化在任何情况下都可使用那么它是无效的特化，这种无效的特化是不被允许的