> ## [返回索引](../index.md)

显式禁用函数用于禁用一个函数的某个版本禁用某个版本的函数可以不是函数模板，示例:
```
template <typename T>
void FN(T) {}
template <>
void FN(int) = delete;
```
这会禁用FN的T类型为int时的模板函数，是的和特化一样这个delete也可以进行推导类型，这个禁用函数和这个是一样的:
```
template <>
void FN<int>(int) = delete;
```

- 补充:
    1. 禁用函数忽略template后的声明必须与被禁用的函数声明一样，如果禁用函数的template为空那么被禁用的函数必须为函数模板(反过来也是一样，被禁用的函数是模板那么禁用函数的模板就必须为空)
    2. 当这种情况下可以使用FN的int参数的版本而对于其它类型参数的版本会直接报错即使这个类型可以隐式转换为int:
        ```
        void FN(int) {}
        template <typename T>
        void FN(T) = delete;/* 此时给FN传入int类型仍然可调用 */
        ```
    3. 禁用函数的template关键字必须写
    4. 不可以以同样的方式= default，除非编译器会默认提供此函数
    5. 禁用函数可以写在任何地方这不影响效果，只要不在函数体内
    6. 如果被禁用的函数有默认实参那么不要在禁用函数中写上错误示范例如:
        ```
        template <typename T>
        void FN(T = 123) {}
        template <typename T>
        void FN(T = 123) = delete;
        ```
    7. 如果禁用函数拥有未被使用的模板参数那么由于编译器无法推导这个禁用函数会在什么时候禁用所以这个时候此禁用函数会视为无效的
    8. 还有一种= delete用于禁用编译器默认在类内生成的某个函数，例如:
    	```
    	class L {
    		L() = delete;
    	};
    	```
		这样会显式禁用构造，tip:
			- 函数声明必须与编译器默认提供的一样(不过你可以加一些限定，例如constexpr)，例如编译器默认提供的某些函数没有参数，所以在这个= delete声明的函数也不能有参数
			- 在编译器可以默认提供这个函数但不满足默认提供的要求且用户未定义此函数那么此函数会隐式禁用
			- 还有= default，与这个同理，只不过变成了显式让编译器提供此函数
	9. 可以delete不存在的函数，在此时就如同函数声明了一样，编译器会认为有这个函数(但是无法调用，会直接编译错误说此函数已被delete)
	10. delete函数是在C++11起引入的，准确来说调用delete的函数或一个函数指针指向一个delete的函数都是非良构的，而不是上文说的报错
	11. delete一个函数也被称为弃置