> ## [返回索引](../index.md)

折叠表达式是C++17引入的，分为一元和二元的，然后又分为左折叠与右折叠，以下为了解释方便把E成为形参包E+角标就是形参包里的第几个参数例如E¹就是第一个，Eⁿ代表形参包里的最后一个参数，如果角标是负数例如E⁻¹那么代表形参包里的倒数第二个参数，I是初值，有些地方的...意思是省略某些东西而不是包展开的那个...

- 一元:
    - 左折叠:
        语法是(... 运算符 E)展开后大概是:  
        `(((E¹ 运算符 E²) 运算符 E³) 运算符 Eⁿ)`
    - 右折叠:
        语法是(E 运算符 ...)展开后大概是:  
        `(E¹ 运算符 (E² 运算符 (E³ 运算符 (... 运算符 (E⁻¹ 运算符 Eⁿ)))))`
    - 如果E是空的那么只能使用以下运算符:
        1. && (空E)结果为true
        2. || (空E)的结果为false
        3. , (空E)的结果为void类型
- 二元:
    - 左折叠:
        语法是(I 运算符 ... 运算符 E)展开后大概是:  
        `(((((I 运算符 E¹) 运算符 E²) 运算符 E³) 运算符 ...) 运算符 Eⁿ)`
    - 右折叠:
        语法是(E 运算符 ... 运算符 I)展开后大概是:  
        `(E¹ 运算符 (E² 运算符 (E³ 运算符 (... 运算符 (E⁻¹ 运算符 (Eⁿ 运算符 I))))))`  
    二元折叠表达式的2个运算符必须相同，如果I里面使用了运算符那么必须加括号例如:  
    `(E + ... + 1 + 1)`会报错，只要改成`(E + ... + (1 + 1))`就行了
- 补充:
	1. 包裹折叠表达式的括号也是折叠表达式的一部分
	2. E可以再套一次表达式(但...不行，这个表达式可以有多个)且这套的一层表达式必须整个都加括号，例如一个一元右折叠((cout << E),...)展开后大概就是:  
    `(cout << E¹,(cout << E²,(cout << E³,(cout << ...,(cout << Eⁿ)))))`
	3. 如果使用E...这样展开那么展开方式是E¹,E²,E³,...,Eⁿ(没有括号)，如果前面还有个逗号例如I,E...那么在E为空时展开后是I而不是\`I,\`，另一种E...,I同理，在E为空时展开为\`I\`而不是\`,I\`函数形参包和模板形参包都可以使用此方法也就是说如果不指定以什么运算符进行展开那么使用\`,\`来隔开每个参数的方式展开  
	需要注意的是如果是模板形参包那么E可以是被操作后的例如`std::remove_const_t<Args>...`，但是函数形参包不行  
	tip: 这2种展开方式不属于折叠表达式，换句话说就是展开的代码如果不涉及展开后的运算与运算符那么这个就不是折叠表达式
	4. 在函数形参包展开的过程中可以使用模板形参包例如假设形参包类型是`class... Args`，模板形参包是`Args... args`那么args的折叠表达式中可以使用Args，例如`forward<Args>(args)...`展开后大概就是`forward<AE¹>(E¹)`,`forward<AE²>(E²),...`，其中AE是Args的第N个参数，也就是Args的展开与args的展开的...都是后面那个...也就是说2个包的展开的折叠表达式的...可以为一个...
	5. 如果折叠表达式中如果含有运算符那么必须使用()包裹整个折叠表达式
	6. 在这里提及一个概念就是模板元，模板元就是利用模板在编译时期做完的运算，比如在编译时查找最小的一个数再或者编译时判断一个类型是否满足条件
- 功能测试宏:
    1. \_\_cpp\_fold\_expressions(201603L) 折叠表达式